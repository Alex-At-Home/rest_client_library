package org.elastic.rest.scala.driver

import org.elastic.rest.scala.driver.utils.MacroUtils

import scala.annotation.StaticAnnotation
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.util.Try
import scala.language.experimental.macros

/**
  * The base operations for the Elasticsearch DSL
  */
object RestBase {

  /** The exception type generated by REST errors
    *
    * @param code The HTTP error code
    * @param message A message summarizing the error (may be empty if no summary can be inferred)
    * @param body The body of the error, if present
    */
  case class RestServerException(code: Int, message: String, body: Option[String]) extends Exception(message)

  /** The exception generated by bad inputs
    *
    * @param message A message summarizing the error (may be empty if no summary can be inferred)
    */
  case class RestRequestException(message: String) extends Exception(message)

  /** An annotation type that provides an implementation for the parameters that the modifier
    * injects into the REST resource
    */
  class Param() extends StaticAnnotation {
    def macroTransform(annottees: Any*) = macro MacroUtils.modifierImpl
  }

  /** An annotation that provides a constructor for the `val` (must be of type `ToStringAnyVal[String]`)
    * that injects the name of the variable as the constructor arg
    */
  class Constant() extends StaticAnnotation {
    def macroTransform(annottees: Any*) = macro MacroUtils.constantImpl
  }

  /** Enables use of value classes for (eg) string constants - must be mixed with AnyVal */
  trait ToStringAnyVal[T] extends Any { self: AnyVal =>
    /** The underlying value */
    def value: T
    override def toString: String = value.toString

  }
  /** Constants used in value class helpers */
  object ToStringAnyVal {
    /** Placeholder that gets filled in by the `@Constant` annotation */
    def AutoGenerate[T] = null.asInstanceOf[T]
  }

  /** Parent type for Modifiers to resources (representing URL parameters)
    * (eg `String*`)
    * Each method in Modifier should be in one of the following formats:
    * * `\@Param def PARAM_TO_INJECT(x: TYPE_OR_TYPE*): this.type = Modifier.body`
    * * `def PARAM_TO_INJECT(x: TYPE_OR_TYPE*): this.type = self.withModifier((CUSTOM_STR, x)).asInstanceOf[this.type]`
    * In the former case then `Modifier.body` is replaced by an auto-generated code block
    */
  trait Modifier

  /** Static util methods for `Modifier` */
  object Modifier {
    /** Placeholder that gets filled in by the `@Param` annotation */
    val Body = null

    /** Converts a key,value pair into a URL parameter "k=v" format
      * @param kv The contents of a modifier in (string, any) pair format
      * @return A string representation in URL parameter format
      */
    def asString(kv: (String, Any)): String = kv match {
      case (k, v) =>
        val paramVal = v match {
          case s: Seq[_] => s.mkString(",")
          case t: ToStringAnyVal[_] => t.toString
          case toStr: AnyRef => toStr.toString
        }
        s"$k=$paramVal"
    }
  }

  /**
    * The base type for the different REST drivers, eg:
    * - Client specific JVM version, eg based on native ES driver
    * - Generic JVM/JS version, eg based on RosHTTP
    */
  trait RestDriver {
    /** Executes the designated operation asynchronously
      *
      * @param baseDriverOp The operation to execute
      * @return A future returning the raw reply or throws `RequestException(code, body, message)`
      */
    def exec(baseDriverOp: BaseDriverOp): Future[String]

    /** The default request-reply timeout for `resultJ`, `resultS` and `result`
      * @return The default request-reply timeout for `resultJ`, `resultS` and `result`
      */
    def timeout: Duration
  }

  val DELETE = "DELETE"
  val GET = "GET"
  val HEAD = "HEAD"
  val POST = "POST"
  val PUT = "PUT"

  /** The base type for driver operations
    * gets mixed in with different traits derived from `Modifier`
    * Gets a concrete case class for each set of such `Modifier`s which are then
    * mixed into the the `RestResource` instances
    *
    * TODO: should we have a streaming version that returns an `InputStream[String/Byte[]]`?
    */
  trait BaseDriverOp {
    /** The resource that is being operated upon
      */
    val resource: RestResource
    /** The operation type if translated to REST
      */
    val op: String
    /** If the operation involves writing data to the resource, this is that data
      */
    val body: Option[String]

    /** The set of modifications, typically filled in by the `Modifier` traits
      * (but modifiers can also be manually generated using `withModifier`)
      */
    val mods: List[(String, Any)]

    /** A set of per operation headers added to the request
      */
    val headers: List[String]

    /** Add a generic string modifier to the driver operation
      *
      * @param kv The key,value pair of the new modifier
      * @return The updated driver operation
      */
    def withModifier(kv: (String, Any)): this.type

    /** Add a generic string header to the driver operation
      *
      * @param h The new header
      * @return The updated driver operation
      */
    def withHeader(h: String): this.type

    /** Add a generic string modifier to the driver operation
      *
      * @param k The new modifier key
      * @param v The new modifier value (should be AnyRef or List[AnyRef])
      * @return The updated driver operation
      */
    def m(k: String, v: Any): this.type = withModifier((k, v))

    /** Add a generic string header to the driver operation
      *
      * @param h The new header
      * @return The updated driver operation
      */
    def h(h: String): this.type = withHeader(h)

    /** Actually executes the operation (async)
      *
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a string
      */
    def execS()(implicit driver: RestDriver): Future[String] = driver.exec(this)

    /** Actually executes the operation (sync)
      *
      * @param timeout Optionally, the amount of time to wait before failing
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a string
      */
    def resultS(timeout: Duration = null)(implicit driver: RestDriver): Try[String] =
      Try { Await.result(this.execS(), Option(timeout).getOrElse(driver.timeout)) }

    /** Retrieves the URL (including params) for the operation on the resource with the modifiers
      *
      * @return The URL (including params) for the operation on the resource with the modifiers
      */
    def getUrl: String = resource.location + mods.headOption.map(_ => "?").getOrElse("") +
      mods.map(Modifier.asString).reverse.mkString("&")

    /** Retrieves the URL (no params) for the operation on the resource with the modifiers
      *
      * @return The URL (no params) for the operation on the resource with the modifiers
      */
    def getPath: String = resource.location + mods.headOption.map(_ => "?").getOrElse("") +
      mods.map(Modifier.asString).reverse.mkString("&")
  }
  object BaseDriverOp {
    /** Extractor for `BaseDriverOp`
      *
      * @param op The operation to decompose
      * @return The 5-tupe
      */
    def unapply(op: BaseDriverOp) = Some((op.resource, op.op, op.body, op.mods, op.headers))
  }

  /** A child of `BaseDriverOp` that includes the typed return type of an operation
    *
    * Various implicits provide `exec` and `result` - see `RuntimeTypedOperation` and eg `StringToTypedHelper`
    *
    * @tparam O The type of the operation return
    */
  trait TypedDriverOp[O] extends BaseDriverOp

  /** The base ES resource, all the case classes should be derived from this
    */
  trait RestResource { self: Product =>

    /** Internal implementation to retrieve the location of the resource, the first time `location` is accessed
      * Replaces $xxx with the corresponding case class parameter, in order
      * TODO: handle a=$a in a segment, eg `/_all/_settings/name=$name/`
      *
      * @return The location of the resource
      */
    private[this] def locationImpl: String = {
      def formatVal(a: Any) = a match {
        case s: Seq[_] => s.mkString(",")
        case toStr: AnyRef => toStr.toString
      }
      val locationTemplate = productPrefix.replace("`", "")
      val splits = locationTemplate.split("/")
      val location = splits match {
        case Array() | Array ("") => locationTemplate // (JVM and JS versions of /)
        case _ =>
          splits.foldLeft(("", 0)) { case ((acc, i), v) =>
            v.headOption
              .filter(_ == '$')
              .map(_ => (acc + "/" + formatVal(productElement(i)), i + 1))
              .getOrElse((acc + "/" + v, i))
          }._1.tail
      }
      location
    }
    /** The location of the resource, generated from the classname
      * by substituting in the field names
      */
    lazy val location = locationImpl
  }
}