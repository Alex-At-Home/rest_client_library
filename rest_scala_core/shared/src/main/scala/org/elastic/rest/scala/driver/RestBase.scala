package org.elastic.rest.scala.driver

import org.elastic.rest.scala.driver.utils.MacroUtils

import scala.annotation.StaticAnnotation
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.util.Try
import scala.language.experimental.macros

/**
  * The base operations for the Elasticsearch DSL
  */
object RestBase {

  /** The exception type generated by REST errors
    *
    * @param code The HTTP error code
    * @param message A message summarizing the error (may be empty if no summary can be inferred)
    * @param body The body of the error, if present
    */
  case class RestServerException(code: Int, message: String, body: Option[String]) extends Exception(message)

  /** The exception generated by bad inputs
    *
    * @param message A message summarizing the error (may be empty if no summary can be inferred)
    */
  case class RestRequestException(message: String) extends Exception(message)

  /** Case classes that want a custom overwrite should inherit this trait and implement
    * `fromTyped`, bypasses needing a JSON library with an overridden serializer etc etc
    */
  trait CustomTypedToString {
    /** Converts self to JSON string
      *
      * @return self as JSON string
      */
    def fromTyped: String
  }

  /** Classes that want a custom overwrite as return types should inherit this trait
    * and implement `toType`, typically still use a JSON library, eg to wrap a JSON element
    *  and provide helpers
    *
    *  This is a pure trait, used by type handlers (like `CirceTypeModule` to decide when to override using
    *  standard JSON processing; all children of it must support a constructor with a single string arg
    *  (ie the response from the REST driver)
    *
    *  Type handlers (like `CirceTypeModule`) should use `NoJsonHelpers.createCustomTyped(s)`
    */
  trait CustomStringToTyped

  /** A trait to be implemented and used as an implicit to define how to go from JSON to string
    * (defaults to `j.toString`)
    *
    * @tparam J The json object type in this library
    */
  trait JsonToStringHelper[J] {
    /** Creates a String from the JSON object of the registered (via implicit) JSON lib
      * (probably can normally be `j.toString`, which is therefore left in as a default)
      *
      * @param j The JSON object
      * @return The JSON
      */
    def fromJson(j: J): String = j.toString
  }

  /** A trait to be implemented as an implicit class to provide the implicit methods `execJ`
    * and `resultJ`. Note different to `JsonToStringHelper` in that you declare this as an implicit class
    * vs `JsonToStringHelper` which you declare as an implicit value
    *
    * @tparam J The JSON type
    */
  trait StringToJsonHelper[J] {
    /** Actually executes the operation (async)
      *
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a JSON object
      */
    def execJ()(implicit driver: RestDriver): Future[J]

    /** Actually executes the operation (sync)
      *
      * @param timeout Optionally, the amount of time to wait before failing
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a JSON object
      */
    def resultJ(timeout: Duration = null)(implicit driver: RestDriver): Try[J] =
      Try { Await.result(this.execJ(), Option(timeout).getOrElse(driver.timeout)) }
  }

  /** An annotation type that provides an implementation for the parameters that the modifier
    * injects into the REST resource
    */
  class Param() extends StaticAnnotation {
    def macroTransform(annottees: Any*) = macro MacroUtils.modifierImpl
  }

  /** Parent type for Modifiers to resources (representing URL parameters)
    * (eg `String*`)
    * Each method in Modifier should be in one of the following formats:
    * * `\@Param def PARAM_TO_INJECT(x: TYPE_OR_TYPE*): this.type = Modifier.body`
    * * `def PARAM_TO_INJECT(x: TYPE_OR_TYPE*): this.type = self.withModifier((CUSTOM_STR, x)).asInstanceOf[this.type]`
    * In the former case then `Modifier.body` is replaced by an auto-generated code block
    */
  trait Modifier { self: BaseDriverOp => }

  /** Static util methods for `Modifier` */
  object Modifier {
    /** Placeholder that gets filled in by the `@Param` annotation */
    val Body = null

    /** Converts a key,value pair into a URL parameter "k=v" format
      * @param kv The contents of a modifier in (string, any) pair format
      * @return A string representation in URL parameter format
      */
    def asString(kv: (String, Any)): String = kv match {
      case (k, v) =>
        val paramVal = v match {
          case s: Seq[_] => s.mkString(",")
          case toStr: AnyRef => toStr.toString
        }
        s"$k=$paramVal"
    }
  }

  /**
    * The base type for the different REST drivers, eg:
    * - Client specific JVM version, eg based on native ES driver
    * - Generic JVM/JS version, eg based on RosHTTP
    */
  trait RestDriver {
    /** Executes the designated operation asynchronously
      *
      * @param baseDriverOp The operation to execute
      * @return A future returning the raw reply or throws `RequestException(code, body, message)`
      */
    def exec(baseDriverOp: BaseDriverOp): Future[String]

    /** The default request-reply timeout for `resultJ`, `resultS` and `result`
      * @return The default request-reply timeout for `resultJ`, `resultS` and `result`
      */
    def timeout: Duration
  }

  val DELETE = "DELETE"
  val GET = "GET"
  val HEAD = "HEAD"
  val POST = "POST"
  val PUT = "PUT"

  /** The base type for driver operations
    * gets mixed in with different traits derived from `Modifier`
    * Gets a concrete case class for each set of such `Modifier`s which are then
    * mixed into the the `RestResource` instances
    *
    * TODO: should we have a streaming version that returns an `InputStream[String/Byte[]]`?
    */
  trait BaseDriverOp {
    /** The resource that is being operated upon
      */
    val resource: RestResource
    /** The operation type if translated to REST
      */
    val op: String
    /** If the operation involves writing data to the resource, this is that data
      */
    val body: Option[String]

    /** The set of modifications, typically filled in by the `Modifier` traits
      * (but modifiers can also be manually generated using `withModifier`)
      */
    val mods: List[(String, Any)]

    /** A set of per operation headers added to the request
      */
    val headers: List[String]

    /** Add a generic string modifier to the driver operation
      *
      * @param kv The key,value pair of the new modifier
      * @return The updated driver operation
      */
    def withModifier(kv: (String, Any)): this.type

    /** Add a generic string header to the driver operation
      *
      * @param h The new header
      * @return The updated driver operation
      */
    def withHeader(h: String): this.type

    /** Add a generic string modifier to the driver operation
      *
      * @param k The new modifier key
      * @param v The new modifier value (should be AnyRef or List[AnyRef])
      * @return The updated driver operation
      */
    def m(k: String, v: Any): this.type = withModifier((k, v))

    /** Add a generic string header to the driver operation
      *
      * @param h The new header
      * @return The updated driver operation
      */
    def h(h: String): this.type = withHeader(h)

    /** Actually executes the operation (async)
      *
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a string
      */
    def execS()(implicit driver: RestDriver): Future[String] = driver.exec(this)

    /** Actually executes the operation (sync)
      *
      * @param timeout Optionally, the amount of time to wait before failing
      * @param driver The driver which executes the operation
      * @return A future containing the result of the operation as a string
      */
    def resultS(timeout: Duration = null)(implicit driver: RestDriver): Try[String] =
      Try { Await.result(this.execS(), Option(timeout).getOrElse(driver.timeout)) }

    /** Retrieves the URL (including params) for the operation on the resource with the modifiers
      *
      * @return The URL (including params) for the operation on the resource with the modifiers
      */
    def getUrl: String = resource.location + mods.headOption.map(_ => "?").getOrElse("") +
      mods.map(Modifier.asString).reverse.mkString("&")

    /** Retrieves the URL (no params) for the operation on the resource with the modifiers
      *
      * @return The URL (no params) for the operation on the resource with the modifiers
      */
    def getPath: String = resource.location + mods.headOption.map(_ => "?").getOrElse("") +
      mods.map(Modifier.asString).reverse.mkString("&")
  }
  object BaseDriverOp {
    /** Extractor for `BaseDriverOp`
      *
      * @param op The operation to decompose
      * @return The 5-tupe
      */
    def unapply(op: BaseDriverOp) = Some((op.resource, op.op, op.body, op.mods, op.headers))
  }

  /** The base ES resource, all the case classes should be derived from this
    */
  trait RestResource { self: Product =>

    /** Internal implementation to retrieve the location of the resource, the first time `location` is accessed
      * Replaces $xxx with the corresponding case class parameter, in order
      * TODO: handle a=$a in a segment, eg `/_all/_settings/name=$name/`
      *
      * @return The location of the resource
      */
    private[this] def locationImpl: String = {
      def formatVal(a: Any) = a match {
        case s: Seq[_] => s.mkString(",")
        case toStr: AnyRef => toStr.toString
      }
      val locationTemplate = productPrefix.replace("`", "")
      val splits = locationTemplate.split("/")
      if (splits.nonEmpty) {
        splits.foldLeft(("", 0)) { case ((acc, i), v) =>
          v.headOption
            .filter(_ == '$')
            .map(_ => (acc + "/" + formatVal(productElement(i)), i + 1))
            .getOrElse((acc + "/" + v, i))
        }._1.tail
      }
      else locationTemplate
    }
    /** The location of the resource, generated from the classname
      * by substituting in the field names
      */
    lazy val location = locationImpl
  }
}