package org.elastic.rest.scala.driver.utils

import utest._
import org.elastic.rest.scala.driver.RestBaseImplicits.CustomTypedToString
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.{SimpleObjectDescription => obj}
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.SimpleObjectDescription
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.SimpleObjectDescription._
import io.circe.parser.parse

import scala.util.Try

object SimpleObjectDescriptionTests extends TestSuite {
  val tests = this {
    "Basic mock functionality - handled" - {

      /** (Package declaration == "obj")
        * `KeyValue` with no `extras`, `FieldValue`, `Constant`, `MultiTypeField` with cardinality == 0 */
      case class Test
        (field1: String, termName: String, termValue: List[Int], valOrVals: List[String])
        extends CustomTypedToString
      {
        @SimpleObjectDescription("obj",
          obj.SimpleObject("insert_here") (
            obj.Field("field1"),
            obj.Constant("const", true),
            obj.KeyValue("termName")(
              obj.SimpleObject(
                obj.Field("termValue"),
                obj.MultiTypeField("valOrVals")
              )
            ),
            obj.KeyValue("termName", "raw.")(obj.FieldValue("termValue"))
          )
        )
        override def fromTyped: String = AutoGenerated
      }
      val test1 = Test("test", "myTermName", List(1, 2, 3), List())

      parse(test1.fromTyped) ==> parse(
        """{ "insert_here": {
              "field1": "test",
              "const": true,
              "myTermName": {
                "termValue": [ 1, 2, 3 ]
              },
              "raw.myTermName": [ 1, 2, 3 ]
          }
        }""".stripMargin)

      //TODO embedded CustomTypeToString (replace "a")

      case class Injected(b: Boolean, d: Double) extends CustomTypedToString {
        @SimpleObjectDescription("obj",
          obj.Field("d"),
          obj.Field("b")
        )
        override def fromTyped: String = AutoGenerated
      }

      /** (No package declaration),
        * Optional `Fields`, `KeyValue` with `extras`, `MultiTypeField` with cardinality == 1 and >1 */
      case class Test2
        (field1: String,
         maybeField2: Option[String], maybeField3: Option[String],
         termName: String, termValue: List[Int], valOrVals: List[String],
         multiVals: List[Injected]
        )
        extends CustomTypedToString
      {
        @SimpleObjectDescription("",
          SimpleObject("insert_here") (
            Field("field1", "test.prefix."),
            Field("maybeField2"),
            Field("maybeField3"),
            KeyValue("termName")(
              SimpleObject(
                Field("termValue"),
                MultiTypeField("valOrVals")
              ),
              MultiTypeField("multiVals", "prefix.test.")
            ),
            KeyValue("termName", "constant.")(ConstantValue("constValue"))
          )
        )
        override def fromTyped: String = AutoGenerated
      }

      val test2 = Test2("test",
        None, Some("test"),
        "myTermName", List(1, 2, 3), List("a"),
        List(Injected(b = true, d = 0.0), Injected(b = false, d = 1.0))
      )

      parse(test2.fromTyped) ==> parse(
        """{ "insert_here": {
            "test.prefix.field1": "test",
            "maybeField3": "test",
            "myTermName": {
              "termName": {
                "termValue": [ 1, 2, 3 ],
                "valOrVals": "a"
              },
              "prefix.test.multiVals": [ { "d": 0.0, "b": true }, { "d": 1.0, "b": false } ]
            },
            "constant.myTermName": "constValue"
          }
        }""".stripMargin)

    }
    "Coverage for val2str" - {

      /** Can't embed arbitrary case classe because we don't have a built-in JSON deser */
      case class WontWork()

      // Check a couple of error cases
      Try { any2Str("a", WontWork(), isFirst = true) }.isFailure ==> true
      Try { any2Str(WontWork()) }.isFailure ==> true

      // Check  the number combos:
      any2Str("a", 1.1.toFloat, isFirst = true).trim().replaceAll("1[.]1[0-9]+", "1.1") ==> """ "a":  1.1 """.trim()
      any2Str("a", 1.1, isFirst = true).trim().replaceAll("1[.]1[0-9]+", "1.1") ==> """ "a":  1.1 """.trim()
      any2Str("a", 1.toLong, isFirst = true).trim() ==> """ "a":  1 """.trim()
      any2Str("a", 1, isFirst = true).trim() ==> """ "a":  1 """.trim()

      //(everything else is tested above)
    }
  }
}
