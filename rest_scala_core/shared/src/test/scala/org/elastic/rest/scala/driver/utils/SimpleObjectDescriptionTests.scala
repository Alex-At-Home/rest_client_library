package org.elastic.rest.scala.driver.utils

import utest._
import org.elastic.rest.scala.driver.RestBaseImplicits.CustomTypedToString
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.{SimpleObjectDescription => obj}
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.SimpleObjectDescription
import org.elastic.rest.scala.driver.utils.NoJsonHelpers.SimpleObjectDescription._
import io.circe.parser.parse

import scala.util.Try

object SimpleObjectDescriptionTests extends TestSuite {
  val tests = this {
    "Basic mock functionality - handled" - {

      //TODO: extra , is have extras?
      //TODO: somehow have field here?

      /** (Package declaration == "obj")
        * `KeyValue` with no `extras`, `FieldValue`, `Constant`, `MultiTypeField` with cardinality == 0 */
      case class Test
        (field1: Either[String, Boolean], `termName`: String, termValue: List[Int], valOrVals: List[String],
         kvMap: Map[String, Option[String]], optionStr: Option[String])
        extends CustomTypedToString
      {
        @SimpleObjectDescription("obj",
          obj.SimpleObject("insert_here") (
            obj.Field("field1"),
            obj.Constant("const", true),
            obj.KeyValue("`termName`")(
              obj.SimpleObject(
                obj.Field("termValue"),
                obj.MultiTypeField("valOrVals")
              )
            ),
            obj.KeyValue("termName", "raw.")(obj.FieldValue("termValue")),
            obj.KeyValue("termName", "extras.")("termValue", obj.Field("optionStr"))
          ),
          obj.KeyValues("kvMap", "a.")()
        )
        override def fromTyped: String = AutoGenerated
      }
      val test1 = Test(
        field1 = Left("test"), `termName` = "myTermName", termValue = List(1, 2, 3), valOrVals = List(),
       kvMap = Map("x" -> None, "y" -> Some("yV"), "z" -> None, "t" -> Some("tV")), optionStr = None
      )

      parse(test1.fromTyped) ==> parse(
        """{ "insert_here": {
              "field1": "test",
              "const": true,
              "myTermName": {
                "termValue": [ 1, 2, 3 ]
              },
              "raw.myTermName": [ 1, 2, 3 ],
              "extras.myTermName": [ 1, 2, 3 ]
          },
          "a.y": "yV",
          "a.t": "tV"
        }""".stripMargin)

      case class Injected(b: Boolean, d: Double) extends CustomTypedToString {
        @SimpleObjectDescription("obj",
          obj.Field("d"),
          obj.Field("b")
        )
        override def fromTyped: String = AutoGenerated
      }

      /** (No package declaration),
        * Optional `Fields`, `KeyValue` with `extras`, `MultiTypeField` with cardinality == 1 and >1 */
      case class Test2
        (field1: Either[String, Boolean],
         maybeField2: Option[String], maybeField3: Option[String],
         termName: String, termValue: List[Int], valOrVals: List[String],
         `multiVals`: List[Injected], emptyMap: Map[String, String]
        )
        extends CustomTypedToString
      {
        @SimpleObjectDescription("",
          SimpleObject("insert_here") (
            Field("field1", "test.prefix."),
            Field("maybeField2"),
            Field("maybeField3"),
            Field("emptyMap", "empty-"),
            MultiTypeField("emptyMap"),
            KeyValue("termName")(
              SimpleObject(
                Field("termValue"),
                MultiTypeField("valOrVals", arrayIfSingleton = false)
              ),
              "value", MultiTypeField("`multiVals`", arrayIfSingleton = false, "prefix.test.")
            ),
            KeyValue("termName", "constant.")(ConstantValue("constValue"))
          )
        )
        override def fromTyped: String = AutoGenerated
      }

      val test2 = Test2(Right(false),
        None, Some("test"),
        "myTermName", List(1, 2, 3), List("a"),
        List(Injected(b = true, d = 0.0), Injected(b = false, d = 1.0)),
        emptyMap = Map()
      )

      parse(test2.fromTyped) ==> parse(
        """{ "insert_here": {
            "test.prefix.field1": false,
            "maybeField3": "test",
            "empty-emptyMap": {},
            "myTermName": {
              "value": {
                "termValue": [ 1, 2, 3 ],
                "valOrVals": "a"
              },
              "prefix.test.multiVals": [ { "d": 0.0, "b": true }, { "d": 1.0, "b": false } ]
            },
            "constant.myTermName": "constValue"
          }
        }""".stripMargin)

    }
    "Coverage for val2str" - {

      /** Can't embed arbitrary case classes because we don't have a built-in JSON deser */
      case class WontWork()

      compileError("""
        case class NotSupportedExtras(kvs: Map[String, String]) extends CustomTypedToString {
          @SimpleObjectDescription("",
            KeyValues("kvs")("injectKey", obj.Constant("const", true))
          )
          override def fromTyped: String = AutoGenerated
      }""")

      // Check a couple of error cases
      Try { any2Str("a", "", WontWork(), isFirst = true) }.isFailure ==> true
      Try { any2Str(WontWork()) }.isFailure ==> true

      // Check the number combos:
      any2Str("a", "", 1.1.toFloat, isFirst = true).trim().replaceAll("1[.]1[0-9]+", "1.1") ==> """ "a":  1.1 """.trim()
      any2Str("a", "", 1.1, isFirst = true).trim().replaceAll("1[.]1[0-9]+", "1.1") ==> """ "a":  1.1 """.trim()
      any2Str("a", "", 1.toLong, isFirst = true).trim() ==> """ "a":  1 """.trim()
      any2Str("a", "", 1, isFirst = true).trim() ==> """ "a":  1 """.trim()

      // Internal map
      parse(s"""{ ${any2Str("a", "", Map("k" -> "v", "b" -> true), isFirst = true)} }""") ==>
        parse("""{ "a": { "k": "v", "b": true } }""")

      //(everything else is tested above)
    }
  }
}
