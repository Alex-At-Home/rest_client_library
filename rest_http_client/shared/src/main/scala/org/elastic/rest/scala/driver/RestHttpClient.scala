package org.elastic.rest.scala.driver

import java.nio.ByteBuffer

import fr.hmil.roshttp.body.BulkBodyPart
import fr.hmil.roshttp.{HttpRequest, Method}
import org.elastic.rest.scala.driver.RestBase.{BaseDriverOp, RestDriver}

import scala.concurrent.Future
import scala.concurrent.duration.Duration
import monix.execution.Scheduler.Implicits.global

/**
  * A simple HTTP client for the REST library, just a thin wrapper around `RosHTTP.HttpRequest`
  * @param requestSettings The settings to apply to each resource operation execution
  */
case class RestHttpClient(requestSettings: HttpRequest) extends RestDriver {

  /** Creates a new HTTP client with settings generated by applying `transform` to the existing settings
    *
    * @param transform The transform function to apply to the current settings
    * @return A new HttpClient with the updated settings
    */
  def changeSettings(transform: HttpRequest => HttpRequest): RestHttpClient = RestHttpClient(transform(requestSettings))

  /**
    * Builds a new HTTP client with a basic authorization header automatically added to all requests
    * @param username Basic auth username
    * @param password Basic auth password
    * @return A new HttpClient with the updated settings
    */
  def withBasicAuth(username: String, password: String): RestHttpClient = {
    val encoding: String = java.util.Base64.getEncoder.encodeToString(s"$username:$password".getBytes)
    val basicAuth = s"Basic $encoding"
    changeSettings(r => r.withHeader("Authorization", basicAuth))
  }

  override def timeout: Duration = requestSettings.timeout

  override def exec(baseDriverOp: BaseDriverOp): Future[String] = {
    def headerToKeyVal(header: String): Option[(String, String)] = header.split("\\s*:\\s*") match {
      case Array(k, v) => Some((k, v))
      case _ => None
    }
    val request =
      Some(requestSettings.withMethod(Method(baseDriverOp.op)).withURL(baseDriverOp.getUrl)) //(includes mods)
        .map { req => baseDriverOp.headers match { // Headers
          case List() => req
          case l @ _ => l.foldLeft(req) { (acc, v) =>
            headerToKeyVal(v).map(kv => acc.withHeader(kv._1, kv._2)).getOrElse(acc)
          }
        }}
        .map { req => baseDriverOp.body match { //Body
          case None => req
          case body => req.withBody(new BulkBodyPart() {
            override def contentData = ByteBuffer.wrap(body.toString.getBytes("utf-8"))
            override def contentType: String = s"application/json; charset=utf-8"
          })
        }}
      .get
    request.send().map { response =>
      response.body
    }
    //TOOD: check in test if mods are needed?
  }
}
